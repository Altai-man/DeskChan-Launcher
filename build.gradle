import edu.sc.seis.launch4j.tasks.Launch4jLibraryTask
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.api.internal.plugins.StartScriptGenerator
import java.util.stream.Collectors

version 'v0.1.1-dev'
ext.defaultModule = 'javafx'

// At first, the application is assembled to this directory. And only then it packs into a zip file.
ext.launch4jDir = "$buildDir/launch4j"

buildscript {
    ext.kotlin_version = '1.1.4'

    repositories {
        mavenCentral()
        jcenter()
    }

    dependencies {
        classpath group: 'org.jetbrains.kotlin', name: 'kotlin-gradle-plugin', version: kotlin_version
        classpath group: 'com.github.jengelman.gradle.plugins', name: 'shadow', version: '2.0.1+'
        classpath group: 'edu.sc.seis.gradle', name: 'launch4j', version: '2.4.1+'
    }
}

apply plugin: 'kotlin'
apply plugin: 'application'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'edu.sc.seis.launch4j'

repositories {
    mavenCentral()
    jcenter()
}

sourceSets {
    def modules = [
            cli,
            javafx
    ]
    modules.forEach {
        it.compileClasspath += sourceSets.main.compileClasspath + sourceSets.main.output
    }
}

dependencies {
    compile group: 'org.jetbrains.kotlin', name: 'kotlin-stdlib-jre8', version: kotlin_version
    compile group: 'org.json', name: 'json', version: '20170516'
    compile group: 'net.lingala.zip4j', name: 'zip4j', version: '1.3.2'
    compile group: 'com.github.sarxos', name: 'windows-registry-util', version: '0.3'
    cliCompile group: 'args4j', name: 'args4j', version: '2.33'
}

compileKotlin {
    kotlinOptions.jvmTarget = "1.8"
}
compileTestKotlin {
    kotlinOptions.jvmTarget = "1.8"
}

run {
    sourceSets.forEach {
        classpath += it.runtimeClasspath
    }
}

static String buildMainClassName(String module = null, String mainClass = "MainKt") {
    def builder = new StringBuilder('info.deskchan.launcher')
    if (module != null) {
        builder.append('.' + module)
    }
    builder.append(".$mainClass")
    return builder.toString()
}

static String shortenName(String name) {
    name.toCharArray()
            .findAll { it.isUpperCase() }
            .inject(new StringBuilder()) { builder, value -> builder.append(value.toLowerCase()) }
            .toString()
}

applicationName = 'DeskChan-Launcher'
ext.shortAppName = shortenName(applicationName)
ext.fullAppName = "$applicationName $version"

mainClassName = buildMainClassName(defaultModule)
sourceCompatibility = 1.8
targetCompatibility = 1.8
compileJava.options.encoding = 'UTF-8'


shadowJar {
    baseName = shortAppName.toUpperCase()
    classifier = 'CORE'
    version = null
}

task cliJar(type: ShadowJar, group: applicationName) {
    baseName = applicationName
    classifier = 'CLI'

    from (sourceSets.cli.output) {
        include '**/*'
    }
    configurations = [project.configurations.cliCompile]

    manifest.attributes 'Main-Class': buildMainClassName('cli'),
                        'Launcher-Module': true
}

task javafxJar(type: ShadowJar, group: applicationName) {
    baseName = applicationName
    classifier = 'JAVAFX'

    from (sourceSets.javafx.output) {
        include '**/*'
    }

    manifest.attributes 'Main-Class': buildMainClassName('javafx', 'JavaFxApplication'),
                        'Launcher-Module': true
}

[shadowJar, cliJar, javafxJar].forEach {
    it.manifest.attributes 'Implementation-Title'  : "${it.baseName}-${it.classifier}",
                           'Implementation-Version': it.version ?: project.version
}

task copyCoreJar(type: Copy, dependsOn: shadowJar, group: applicationName) {
    from shadowJar.archivePath
    into launch4jDir
}

task createConsoleExe(type: Launch4jLibraryTask, group: applicationName) {
    inputs.file(cliJar.outputs)

    outfile = "${shortAppName}.exe"
    mainClassName = buildMainClassName('cli')
    jar = "$libsDir/${tasks.cliJar.archiveName}"
    icon = file("$projectDir/icons/cli.ico")
    headerType = 'console'
}

task createJavafxExe(type: Launch4jLibraryTask, group: applicationName) {
    inputs.file(javafxJar.outputs)

    outfile = "${applicationName}.exe"
    mainClassName = buildMainClassName('javafx', 'JavaFxApplication')
    jar = "$libsDir/${tasks.javafxJar.archiveName}"
    icon = file("$projectDir/icons/javafx.ico")

    // Can make debugging simpler.
    // headerType = 'console'
}

[createConsoleExe, createJavafxExe].forEach {
    it.copyConfigurable = files()
    it.productName = it.internalName = it.fileDescription = applicationName
    it.classpath += shadowJar.archiveName
}

task createStartScriptsForConsoleExe(type: MyStartScripts, group: applicationName) {
    outputDir = file(launch4jDir)
    mainClassName = createConsoleExe.mainClassName
    applicationName = shortAppName
    classpath = files(createConsoleExe.outfile, shadowJar.archiveName)
}

task createStartScriptsForJavafxExe(type: MyStartScripts, group: applicationName) {
    outputDir = file(launch4jDir)
    mainClassName = createJavafxExe.mainClassName
    applicationName = project.applicationName
    classpath = files(createJavafxExe.outfile, shadowJar.archiveName)
}

task wrapFilesWithDir(type: Copy, group: applicationName,
        dependsOn: [copyCoreJar,
                    createConsoleExe, createJavafxExe,
                    createStartScriptsForConsoleExe, createStartScriptsForJavafxExe]) {
    description "Used to create a ZIP-archive with a directory at the top level."

    from launch4jDir
    into "$buildDir/$fullAppName"
}

task buildDistZip(type: Zip, dependsOn: wrapFilesWithDir, group: applicationName) {
    from buildDir
    include "${wrapFilesWithDir.destinationDir.name}/*"
    archiveName "${fullAppName}.zip"
    destinationDir file(distsDir)
}


class MyStartScripts extends org.gradle.jvm.application.tasks.CreateStartScripts {
    @Override
    @TaskAction
    void generate() {
        def generator = new StartScriptGenerator(unixStartScriptGenerator, windowsStartScriptGenerator)
        generator.setApplicationName(getApplicationName())
        generator.setMainClassName(getMainClassName())
        generator.setDefaultJvmOpts(getDefaultJvmOpts())
        generator.setOptsEnvironmentVar(getOptsEnvironmentVar())
        generator.setExitEnvironmentVar(getExitEnvironmentVar())
        generator.setClasspath(getRelativeClasspath())
        generator.setScriptRelPath(getUnixScript().getName())
        generator.generateUnixScript(getUnixScript())
        // generator.generateWindowsScript(getWindowsScript())
    }

    private Iterable<String> getRelativeClasspath() {
        this.getClasspath().getFiles().stream().map { it.getName() }.collect(Collectors.toList())
    }
}
